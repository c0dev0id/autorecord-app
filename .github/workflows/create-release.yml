name: Create Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag (e.g., v1.0.0 or 1.0.0). Leave empty to auto-increment patch version.'
        required: false
        type: string
        default: ''

jobs:
  create-release:
    name: Create Release and Build APK
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for changelog generation

      - name: Determine version
        id: determine_version
        run: |
          INPUT_VERSION="${{ github.event.inputs.version }}"
          
          # If input is empty, auto-increment from last tag
          if [ -z "$INPUT_VERSION" ]; then
            # Get the last tag, or default to v0.0.0 if this is the first release
            LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
            echo "Last tag: $LAST_TAG"
            
            # Extract version numbers (remove 'v' prefix if present)
            VERSION_NUM="${LAST_TAG#v}"
            
            # Validate version format before splitting
            if [[ ! "$VERSION_NUM" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "Error: Last tag '$LAST_TAG' is not in valid semantic version format (major.minor.patch)"
              exit 1
            fi
            
            # Split into major.minor.patch
            IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION_NUM"
            
            # Increment patch version (regex validation ensures numeric values)
            PATCH=$((PATCH + 1))
            
            # Construct new version with 'v' prefix
            VERSION="v${MAJOR}.${MINOR}.${PATCH}"
            echo "Auto-incremented version: $VERSION"
          else
            # If input doesn't start with 'v', add it
            if [[ ! "$INPUT_VERSION" =~ ^v ]]; then
              VERSION="v${INPUT_VERSION}"
              echo "Added 'v' prefix: $VERSION"
            else
              VERSION="$INPUT_VERSION"
              echo "Using provided version: $VERSION"
            fi
          fi
          
          # Export version for use in subsequent steps
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Final version: $VERSION"

      - name: Validate version format
        run: |
          VERSION="${{ env.VERSION }}"
          if [[ ! "$VERSION" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Error: Version must be in format v1.0.0 (with 'v' prefix)"
            exit 1
          fi
          echo "Version format is valid: $VERSION"

      - name: Check if tag already exists
        run: |
          VERSION="${{ env.VERSION }}"
          if git rev-parse "$VERSION" >/dev/null 2>&1; then
            echo "Error: Tag $VERSION already exists!"
            exit 1
          fi
          echo "Tag $VERSION does not exist, proceeding..."

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Create and push tag
        run: |
          VERSION="${{ env.VERSION }}"
          git tag -a "$VERSION" -m "Release $VERSION"
          git push origin "$VERSION"
          echo "Created and pushed tag: $VERSION"

      - name: Generate changelog
        id: changelog
        run: |
          VERSION="${{ env.VERSION }}"

          # Get the previous tag (if any)
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")

          if [ -z "$PREVIOUS_TAG" ]; then
            echo "No previous tag found, generating full changelog"
            COMMITS=$(git log --pretty=format:"- %s" --no-merges)
          else
            echo "Previous tag: $PREVIOUS_TAG"
            COMMITS=$(git log ${PREVIOUS_TAG}..HEAD --pretty=format:"- %s" --no-merges)
          fi

          # Filter and categorize commits for end users
          FEATURES=""
          IMPROVEMENTS=""
          FIXES=""
          OTHER=""

          while IFS= read -r line; do
            # Skip lines starting with merge, workflow files, or CI keywords
            if echo "$line" | grep -qiE "^- (merge |rebase |update.*workflow|update.*github action|ci:|cd:)"; then
              continue
            fi

            # Skip test-only commits
            if echo "$line" | grep -qiE "^- (test:|spec:|add.*test|update.*test)$"; then
              continue
            fi

            # Categorize commits
            if echo "$line" | grep -qiE "^- (feat:|feature:)"; then
              FEATURES="${FEATURES}${line}\n"
            elif echo "$line" | grep -qiE "^- (fix:|bugfix:|bug:)"; then
              FIXES="${FIXES}${line}\n"
            elif echo "$line" | grep -qiE "^- (improve:|improvement:|enhancement:|perf:|performance:)"; then
              IMPROVEMENTS="${IMPROVEMENTS}${line}\n"
            else
              # Include all other commits as-is to avoid removing important context
              OTHER="${OTHER}${line}\n"
            fi
          done <<< "$COMMITS"

          # Build the changelog
          CHANGELOG="## What's Changed\n\n"

          if [ -n "$FEATURES" ]; then
            CHANGELOG="${CHANGELOG}### âœ¨ New Features\n${FEATURES}\n"
          fi

          if [ -n "$IMPROVEMENTS" ]; then
            CHANGELOG="${CHANGELOG}### ðŸš€ Improvements\n${IMPROVEMENTS}\n"
          fi

          if [ -n "$FIXES" ]; then
            CHANGELOG="${CHANGELOG}### ðŸ› Bug Fixes\n${FIXES}\n"
          fi

          if [ -n "$OTHER" ]; then
            CHANGELOG="${CHANGELOG}### ðŸ“ Other Changes\n${OTHER}\n"
          fi

          # If no categorized changes, show a simple message
          if [ -z "$FEATURES" ] && [ -z "$IMPROVEMENTS" ] && [ -z "$FIXES" ] && [ -z "$OTHER" ]; then
            CHANGELOG="## What's Changed\n\nInitial release of Motorcycle Voice Notes.\n\n"
          fi

          # Add installation instructions
          CHANGELOG="${CHANGELOG}---\n\n"
          CHANGELOG="${CHANGELOG}## ðŸ“¦ Installation\n\n"
          CHANGELOG="${CHANGELOG}1. Download the APK file below\n"
          CHANGELOG="${CHANGELOG}2. Enable \"Install from Unknown Sources\" on your Android device if prompted\n"
          CHANGELOG="${CHANGELOG}3. Install the APK\n"
          CHANGELOG="${CHANGELOG}4. Grant required permissions (microphone, location, storage)\n"
          CHANGELOG="${CHANGELOG}5. Configure save directory and trigger app\n\n"
          CHANGELOG="${CHANGELOG}## ðŸ“± Requirements\n\n"
          CHANGELOG="${CHANGELOG}- Android 8.0 (API 26) or higher\n"
          CHANGELOG="${CHANGELOG}- GPS capability\n"
          CHANGELOG="${CHANGELOG}- Microphone\n\n"
          CHANGELOG="${CHANGELOG}For more information, visit the [repository](https://github.com/${{ github.repository }})."

          # Save changelog to file
          echo -e "$CHANGELOG" > changelog.md
          cat changelog.md

          # Save for later use
          echo "changelog_file=changelog.md" >> $GITHUB_OUTPUT

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          # Built-in Gradle cache is sufficient - handles dependencies, wrappers, and build-cache
          cache: gradle

      - name: Grant execute permission for gradlew
        run: chmod +x gradlew

      # Cache Android SDK components to avoid re-downloading (~1-2 GB)
      # This significantly speeds up workflow runs by caching SDK packages
      - name: Cache Android SDK
        uses: actions/cache@v4
        with:
          path: |
            ~/.android/build-cache
            ~/.android/cache
          key: ${{ runner.os }}-android-sdk-${{ hashFiles('**/build.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-android-sdk-

      - name: Setup Android SDK
        uses: android-actions/setup-android@v3

      - name: Create gradle.properties with service account JSON
        run: |
          echo "GOOGLE_CLOUD_SERVICE_ACCOUNT_JSON=${{ toJSON(secrets.GOOGLE_CLOUD_SERVICE_ACCOUNT_JSON) }}" >> gradle.properties
          echo "OSM_CLIENT_ID=${{ secrets.OSM_CLIENT_ID }}" >> gradle.properties
          echo "org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8" >> gradle.properties
          echo "android.useAndroidX=true" >> gradle.properties
          echo "android.enableJetifier=true" >> gradle.properties
          echo "kotlin.code.style=official" >> gradle.properties

      # Enable Gradle build cache and parallel execution for faster incremental builds
      # --build-cache: Enables Gradle's build cache for reusing outputs
      # --parallel: Executes tasks in parallel when possible
      - name: Build Debug APK
        run: ./gradlew assembleDebug --stacktrace --build-cache --parallel

      - name: Rename APKs
        run: |
          VERSION="${{ env.VERSION }}"
          VERSION_NUMBER="${VERSION#v}"  # Remove 'v' prefix for filename

          echo "Version: $VERSION"
          echo "Version number: $VERSION_NUMBER"
          echo "Listing APK files:"
          ls -la app/build/outputs/apk/debug/ || echo "Debug directory not found"

          # Rename debug APK
          if [ -f "app/build/outputs/apk/debug/app-debug.apk" ]; then
            cp app/build/outputs/apk/debug/app-debug.apk motorcycle-voice-notes-${VERSION_NUMBER}-debug.apk
            echo "DEBUG_APK_FILE=motorcycle-voice-notes-${VERSION_NUMBER}-debug.apk" >> $GITHUB_ENV
            echo "Debug APK found and renamed"
          else
            echo "Error: No debug APK found!"
            exit 1
          fi

          # Show APK sizes
          echo "APK sizes:"
          ls -lh $DEBUG_APK_FILE

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ env.VERSION }}
          name: Motorcycle Voice Notes ${{ env.VERSION }}
          body_path: changelog.md
          files: |
            ${{ env.DEBUG_APK_FILE }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Build Summary
        run: |
          VERSION="${{ env.VERSION }}"
          echo "## ðŸŽ‰ Release Created Successfully!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version**: $VERSION" >> $GITHUB_STEP_SUMMARY
          echo "**Release APK Type**: ${{ env.APK_TYPE }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**APK Files**:" >> $GITHUB_STEP_SUMMARY
          echo "- Debug APK: ${{ env.DEBUG_APK_FILE }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**APK Sizes**:" >> $GITHUB_STEP_SUMMARY
          ls -lh ${{ env.DEBUG_APK_FILE }} >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“‹ Changelog" >> $GITHUB_STEP_SUMMARY
          cat changelog.md >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "View the release at: https://github.com/${{ github.repository }}/releases/tag/$VERSION" >> $GITHUB_STEP_SUMMARY
